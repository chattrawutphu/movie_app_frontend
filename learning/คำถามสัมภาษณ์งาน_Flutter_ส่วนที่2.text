===== คำถามสัมภาษณ์งาน Flutter: ส่วนที่ 2 (การจัดการ State และ API) =====

ในส่วนนี้รวบรวมคำถามและคำตอบในการสัมภาษณ์งานเกี่ยวกับการจัดการ State และการทำงานกับ API ใน Flutter

--- 1. คำถามเกี่ยวกับการจัดการ State ---

Q1: อะไรคือ State ใน Flutter และทำไมการจัดการ State จึงสำคัญ?
A: State ใน Flutter คือข้อมูลที่สามารถเปลี่ยนแปลงระหว่างการทำงานของแอพและส่งผลต่อการแสดงผล UI

   การจัดการ State มีความสำคัญเพราะ:
   - ช่วยให้ UI แสดงข้อมูลที่ถูกต้องและเป็นปัจจุบัน
   - ช่วยในการจัดการข้อมูลระหว่างหน้าจอต่างๆ
   - หากจัดการไม่ดี จะทำให้แอพมีปัญหาประสิทธิภาพและยากต่อการบำรุงรักษา
   - เป็นรากฐานสำคัญของการสร้างแอพที่มีปฏิสัมพันธ์กับผู้ใช้

Q2: อธิบายความแตกต่างระหว่าง Ephemeral State และ App State
A: - Ephemeral State (Local State): 
     * เป็น state ที่อยู่ในเฉพาะ widget เดียว
     * ไม่ต้องแชร์กับ widget อื่นๆ ในแอพ
     * จัดการได้ง่ายด้วย StatefulWidget และ setState()
     * ตัวอย่าง: การเปิด/ปิดเมนู, ค่าใน TextField, การเลือกแท็บ

   - App State (Shared State):
     * เป็น state ที่แชร์ระหว่าง widget หลายตัว
     * มีผลกระทบต่อหลายส่วนของแอพ
     * ต้องใช้วิธีการจัดการ state แบบพิเศษ เช่น Provider, Bloc, Redux
     * ตัวอย่าง: ข้อมูลผู้ใช้, ตะกร้าสินค้า, การตั้งค่าแอพ

Q3: อธิบายวิธีจัดการ State ใน Flutter ที่คุณรู้จัก พร้อมข้อดี-ข้อเสีย
A: 1. setState():
     * ข้อดี: ง่าย, เป็นพื้นฐานของ Flutter, เหมาะกับ state ง่ายๆ
     * ข้อเสีย: ไม่เหมาะกับ state ซับซ้อนหรือต้องแชร์ระหว่าง widgets

   2. Provider:
     * ข้อดี: เรียบง่าย, เป็นทางการจาก Flutter team, ประสิทธิภาพดี
     * ข้อเสีย: อาจไม่เหมาะกับแอพขนาดใหญ่ที่มี state ซับซ้อนมาก

   3. Bloc/Cubit:
     * ข้อดี: แยกส่วน UI และ logic ชัดเจน, ทดสอบง่าย, เหมาะกับแอพซับซ้อน
     * ข้อเสีย: โค้ดเยอะ, เรียนรู้ยาก, อาจเกินความจำเป็นสำหรับแอพเล็ก

   4. GetX:
     * ข้อดี: เขียนโค้ดน้อย, มี utilities มากมาย, ประสิทธิภาพดี
     * ข้อเสีย: ไม่เป็นทางการ, อาจทำให้โค้ดอ่านยาก, ขัดแย้งกับแนวทาง Flutter

   5. Redux:
     * ข้อดี: state flow ชัดเจน, คาดเดาได้, เหมาะกับแอพซับซ้อนมาก
     * ข้อเสีย: boilerplate code เยอะ, เรียนรู้ยาก

Q4: อธิบายการทำงานของ Provider และยกตัวอย่างการใช้งาน
A: Provider เป็นวิธีจัดการ state ที่ใช้ InheritedWidget ทำให้ widgets สามารถเข้าถึงข้อมูลได้โดยไม่ต้องส่งผ่าน props

   การทำงาน:
   1. สร้าง Model ที่ extends ChangeNotifier
   2. เมื่อข้อมูลเปลี่ยน เรียก notifyListeners() เพื่อแจ้ง widgets
   3. ครอบ widgets ด้วย ChangeNotifierProvider
   4. ใช้ Consumer หรือ context.watch() เพื่อฟัง changes

   ตัวอย่าง:
   ```dart
   // 1. สร้าง Model
   class CounterModel extends ChangeNotifier {
     int _count = 0;
     int get count => _count;
     
     void increment() {
       _count++;
       notifyListeners();
     }
   }
   
   // 2. ติดตั้ง Provider
   void main() {
     runApp(
       ChangeNotifierProvider(
         create: (context) => CounterModel(),
         child: MyApp(),
       ),
     );
   }
   
   // 3. ใช้งาน Provider
   class CounterWidget extends StatelessWidget {
     @override
     Widget build(BuildContext context) {
       return Column(
         children: [
           // ดึงข้อมูลและฟังการเปลี่ยนแปลง
           Text('Count: ${context.watch<CounterModel>().count}'),
           
           // เรียกใช้ method โดยไม่ rebuild
           ElevatedButton(
             onPressed: () => context.read<CounterModel>().increment(),
             child: Text('Increment'),
           ),
         ],
       );
     }
   }
   ```

Q5: อธิบายแนวคิดของ BLoC pattern และเปรียบเทียบกับ Provider
A: BLoC (Business Logic Component) เป็นรูปแบบการจัดการ state ที่แยก business logic ออกจาก UI อย่างชัดเจน

   แนวคิด:
   - UI ส่ง Events เข้าสู่ BLoC
   - BLoC ประมวลผลและส่ง States กลับไปยัง UI
   - ใช้ Streams เพื่อส่งข้อมูลระหว่าง BLoC และ UI

   เปรียบเทียบกับ Provider:
   - Provider: ง่ายกว่า, โค้ดน้อยกว่า, เหมาะกับแอพเล็กถึงกลาง
   - BLoC: แยกส่วนชัดเจนกว่า, ทดสอบง่ายกว่า, เหมาะกับแอพซับซ้อน
   
   ควรเลือก Provider เมื่อต้องการความเรียบง่ายและพัฒนาเร็ว
   ควรเลือก BLoC เมื่อมี business logic ซับซ้อนและต้องการทดสอบอย่างละเอียด

Q6: InheritedWidget คืออะไรและมีความสำคัญอย่างไรในการจัดการ state?
A: InheritedWidget เป็น widget พื้นฐานที่ใช้สำหรับส่งผ่านข้อมูลลงไปในต้นไม้ widget โดยไม่ต้องส่งผ่าน constructor (prop drilling)

   ความสำคัญ:
   - เป็นพื้นฐานของการจัดการ state แบบต่างๆ ใน Flutter (Provider, Theme, MediaQuery)
   - ช่วยลดการส่งผ่าน props ไปยัง widgets ที่ซ้อนกันหลายชั้น
   - Flutter rebuild เฉพาะ widgets ที่ใช้ข้อมูลจาก InheritedWidget ที่เปลี่ยนแปลง
   - ทำให้โค้ดสะอาดและบำรุงรักษาง่ายขึ้น

   Provider จริงๆ แล้วคือการใช้ InheritedWidget ในรูปแบบที่ใช้งานง่ายและมีประสิทธิภาพมากขึ้น

Q7: ทำไมการใช้ setState() จึงไม่เหมาะกับการจัดการ state ในแอพขนาดใหญ่?
A: setState() ไม่เหมาะกับแอพขนาดใหญ่เพราะ:
   - สร้าง tight coupling ระหว่าง UI และ logic
   - ยากต่อการแชร์ state ระหว่าง widgets ที่ไม่มีความสัมพันธ์กัน
   - อาจทำให้เกิดการ rebuild ที่ไม่จำเป็น ส่งผลต่อประสิทธิภาพ
   - ยากต่อการทดสอบเนื่องจาก logic ผูกติดกับ StatefulWidget
   - code ยากต่อการบำรุงรักษาเมื่อแอพเติบโตขึ้น
   - ไม่สามารถจัดการกับ state ซับซ้อนได้อย่างมีประสิทธิภาพ

   ในแอพขนาดใหญ่ ควรใช้วิธีการที่แยก business logic ออกจาก UI เช่น Provider, Bloc, Redux

--- 2. คำถามเกี่ยวกับการทำงานกับ API ---

Q8: อธิบายวิธีการเชื่อมต่อกับ RESTful API ใน Flutter
A: การเชื่อมต่อกับ RESTful API ใน Flutter ทำได้หลายวิธี:

   1. ใช้ package http (พื้นฐาน):
   ```dart
   import 'package:http/http.dart' as http;
   import 'dart:convert';
   
   Future<List<User>> fetchUsers() async {
     final response = await http.get(Uri.parse('https://api.example.com/users'));
     
     if (response.statusCode == 200) {
       final List<dynamic> data = jsonDecode(response.body);
       return data.map((json) => User.fromJson(json)).toList();
     } else {
       throw Exception('Failed to load users');
     }
   }
   ```

   2. ใช้ package dio (มีฟีเจอร์มากกว่า):
   ```dart
   import 'package:dio/dio.dart';
   
   final dio = Dio();
   
   Future<List<User>> fetchUsers() async {
     try {
       final response = await dio.get('https://api.example.com/users');
       final List<dynamic> data = response.data;
       return data.map((json) => User.fromJson(json)).toList();
     } catch (e) {
       throw Exception('Failed to load users: $e');
     }
   }
   ```

   การจัดการที่สำคัญ:
   - การแปลง JSON เป็น Dart objects ด้วย Model classes
   - การจัดการ errors และ exceptions
   - การใช้ async/await สำหรับการทำงานแบบ asynchronous
   - การแสดง loading state และ error state ใน UI

Q9: อธิบายการสร้าง Model class จาก JSON response
A: การสร้าง Model class จาก JSON response มีขั้นตอนดังนี้:

   1. วิเคราะห์โครงสร้าง JSON response
   2. สร้าง class ที่มี fields ตรงกับข้อมูลใน JSON
   3. สร้าง constructor และ factory method สำหรับแปลง JSON

   ```dart
   // JSON: {"id": 1, "name": "John", "email": "john@example.com", "isActive": true}
   
   class User {
     final int id;
     final String name;
     final String email;
     final bool isActive;
     
     User({
       required this.id,
       required this.name,
       required this.email,
       required this.isActive,
     });
     
     // Factory constructor สำหรับแปลง JSON เป็น User object
     factory User.fromJson(Map<String, dynamic> json) {
       return User(
         id: json['id'],
         name: json['name'],
         email: json['email'],
         isActive: json['isActive'],
       );
     }
     
     // Method สำหรับแปลง User object เป็น JSON
     Map<String, dynamic> toJson() {
       return {
         'id': id,
         'name': name,
         'email': email,
         'isActive': isActive,
       };
     }
   }
   ```

   สำหรับโปรเจคใหญ่ อาจใช้ packages เช่น json_serializable หรือ freezed เพื่อสร้าง Model class โดยอัตโนมัติ

Q10: อธิบายการใช้ FutureBuilder และ AsyncSnapshot
A: FutureBuilder เป็น widget ที่ช่วยในการแสดง UI ตามสถานะของ Future (เช่น การเรียก API)

   ```dart
   FutureBuilder<List<User>>(
     future: fetchUsers(),  // Future ที่จะติดตาม
     builder: (context, snapshot) {
       // ตรวจสอบสถานะของ Future
       if (snapshot.connectionState == ConnectionState.waiting) {
         // กำลังโหลด
         return Center(child: CircularProgressIndicator());
       } else if (snapshot.hasError) {
         // เกิดข้อผิดพลาด
         return Center(child: Text('Error: ${snapshot.error}'));
       } else if (!snapshot.hasData || snapshot.data!.isEmpty) {
         // ไม่มีข้อมูล
         return Center(child: Text('No users found'));
       } else {
         // มีข้อมูล
         return ListView.builder(
           itemCount: snapshot.data!.length,
           itemBuilder: (context, index) {
             return ListTile(
               title: Text(snapshot.data![index].name),
               subtitle: Text(snapshot.data![index].email),
             );
           },
         );
       }
     },
   )
   ```

   AsyncSnapshot มีคุณสมบัติสำคัญ:
   - connectionState: สถานะของ Future (none, waiting, active, done)
   - data: ข้อมูลที่ได้จาก Future (ถ้ามี)
   - error: ข้อผิดพลาดจาก Future (ถ้ามี)
   - hasData: ตรวจสอบว่ามีข้อมูลหรือไม่
   - hasError: ตรวจสอบว่ามีข้อผิดพลาดหรือไม่

Q11: อธิบายข้อแตกต่างระหว่าง http package และ dio package
A: ทั้ง http และ dio เป็น packages สำหรับการเชื่อมต่อ HTTP ใน Flutter แต่มีความแตกต่างดังนี้:

   http package:
   - เป็น package พื้นฐานจาก Dart team
   - มีขนาดเล็ก เรียบง่าย
   - ต้องแปลง JSON ด้วยตัวเอง (jsonDecode/jsonEncode)
   - ไม่มี interceptors, ไม่รองรับ request cancellation

   dio package:
   - มีฟีเจอร์ครบครันกว่ามาก
   - รองรับ interceptors (สำหรับ auth token, logging)
   - รองรับ request cancellation
   - แปลง JSON อัตโนมัติ
   - มีการจัดการ FormData สำหรับอัพโหลดไฟล์
   - รองรับการตั้งค่า timeout, การทำ retry อัตโนมัติ
   - มี transformer สำหรับแปลงข้อมูล

   เลือก http เมื่อต้องการความเรียบง่าย package ขนาดเล็ก
   เลือก dio เมื่อต้องการฟีเจอร์เพิ่มเติมและทำงานกับ API ที่ซับซ้อน

Q12: อธิบายวิธีการจัดการ Authentication ใน API calls
A: การจัดการ Authentication ใน API calls ทำได้หลายวิธี:

   1. การส่ง token ใน header ทุกครั้ง:
   ```dart
   Future<User> getProfile() async {
     final token = await getTokenFromStorage();
     final response = await http.get(
       Uri.parse('https://api.example.com/profile'),
       headers: {
         'Authorization': 'Bearer $token',
         'Content-Type': 'application/json',
       },
     );
     // จัดการ response
   }
   ```

   2. การใช้ interceptors (กับ dio):
   ```dart
   final dio = Dio();
   
   void setupAuthInterceptor() {
     dio.interceptors.add(InterceptorsWrapper(
       onRequest: (options, handler) async {
         final token = await getTokenFromStorage();
         options.headers['Authorization'] = 'Bearer $token';
         return handler.next(options);
       },
       onError: (DioError e, handler) async {
         if (e.response?.statusCode == 401) {
           // Token หมดอายุ, refresh token
           final newToken = await refreshToken();
           // ทำ request ใหม่ด้วย token ใหม่
           // ...
         }
         return handler.next(e);
       },
     ));
   }
   ```

   3. การสร้าง API service class:
   ```dart
   class ApiService {
     final Dio _dio;
     
     ApiService() : _dio = Dio() {
       _dio.options.baseUrl = 'https://api.example.com';
       _setupAuthInterceptor();
     }
     
     void _setupAuthInterceptor() {
       // เหมือนตัวอย่างข้างบน
     }
     
     Future<User> getProfile() async {
       final response = await _dio.get('/profile');
       return User.fromJson(response.data);
     }
     
     // methods อื่นๆ
   }
   ```

Q13: คำว่า serialization และ deserialization ในบริบทของการทำงานกับ API คืออะไร?
A: - Serialization: กระบวนการแปลง Dart objects เป็นรูปแบบที่สามารถส่งผ่านเครือข่ายได้ (เช่น JSON)
   - Deserialization: กระบวนการแปลงข้อมูลที่ได้รับ (เช่น JSON) เป็น Dart objects

   ในการทำงานกับ API:
   1. Serialization เกิดขึ้นเมื่อส่งข้อมูลไปยัง API (เช่น การสร้างหรืออัพเดตข้อมูล)
      ```dart
      // แปลง User object เป็น JSON เพื่อส่งไปยัง API
      final user = User(name: 'John', email: 'john@example.com');
      final response = await http.post(
        Uri.parse('https://api.example.com/users'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode(user.toJson()),  // Serialization
      );
      ```

   2. Deserialization เกิดขึ้นเมื่อรับข้อมูลจาก API
      ```dart
      // แปลง JSON response เป็น User object
      final response = await http.get(Uri.parse('https://api.example.com/users/1'));
      final userData = jsonDecode(response.body);
      final user = User.fromJson(userData);  // Deserialization
      ```

   Packages ที่ช่วยในการทำ serialization/deserialization:
   - json_serializable: ใช้ code generation สร้าง methods อัตโนมัติ
   - freezed: สร้าง immutable models พร้อม serialization
   - built_value: สร้าง immutable models ที่ปลอดภัยในการใช้งาน

Q14: อธิบายวิธีการอัพโหลดไฟล์ใน Flutter
A: การอัพโหลดไฟล์ใน Flutter ทำได้ดังนี้:

   1. เลือกไฟล์ (ใช้ package เช่น image_picker):
   ```dart
   import 'package:image_picker/image_picker.dart';
   
   Future<File?> pickImage() async {
     final picker = ImagePicker();
     final pickedFile = await picker.pickImage(source: ImageSource.gallery);
     
     if (pickedFile != null) {
       return File(pickedFile.path);
     }
     return null;
   }
   ```

   2. อัพโหลดไฟล์ด้วย http (ไฟล์เดียว):
   ```dart
   Future<void> uploadImage(File file) async {
     var request = http.MultipartRequest(
       'POST',
       Uri.parse('https://api.example.com/upload'),
     );
     
     request.files.add(
       await http.MultipartFile.fromPath(
         'image',
         file.path,
       ),
     );
     
     request.headers.addAll({
       'Authorization': 'Bearer $token',
     });
     
     final response = await request.send();
     if (response.statusCode == 200) {
       print('Upload success');
     } else {
       print('Upload failed');
     }
   }
   ```

   3. อัพโหลดไฟล์ด้วย dio (มีความสามารถมากกว่า):
   ```dart
   Future<void> uploadImageWithDio(File file) async {
     final formData = FormData.fromMap({
       'image': await MultipartFile.fromFile(
         file.path,
         filename: file.path.split('/').last,
       ),
       'type': 'profile',
     });
     
     try {
       final response = await dio.post(
         'https://api.example.com/upload',
         data: formData,
         onSendProgress: (sent, total) {
           // แสดงความคืบหน้า
           final progress = (sent / total * 100).toStringAsFixed(0);
           print('Upload progress: $progress%');
         },
       );
       
       print('Upload success: ${response.data}');
     } catch (e) {
       print('Upload error: $e');
     }
   }
   ```

Q15: อธิบายวิธีการทดสอบ (Testing) การเรียก API ใน Flutter
A: การทดสอบการเรียก API ใน Flutter ทำได้หลายวิธี:

   1. Unit Testing ด้วย mockito:
   ```dart
   // ทดสอบ API service
   void main() {
     late MockHttpClient mockHttpClient;
     late ApiService apiService;
     
     setUp(() {
       mockHttpClient = MockHttpClient();
       apiService = ApiService(client: mockHttpClient);
     });
     
     test('fetchUsers returns list of users when successful', () async {
       // กำหนด mock response
       when(mockHttpClient.get(any))
         .thenAnswer((_) async => http.Response(
           '[{"id": 1, "name": "John"}]',
           200,
         ));
       
       // เรียกใช้ method ที่ต้องการทดสอบ
       final users = await apiService.fetchUsers();
       
       // ตรวจสอบผลลัพธ์
       expect(users.length, 1);
       expect(users[0].id, 1);
       expect(users[0].name, 'John');
       
       // ตรวจสอบว่ามีการเรียก API ถูกต้อง
       verify(mockHttpClient.get(
         Uri.parse('https://api.example.com/users'),
       )).called(1);
     });
     
     test('fetchUsers throws exception when API fails', () async {
       // กำหนด mock error response
       when(mockHttpClient.get(any))
         .thenAnswer((_) async => http.Response(
           '{"error": "Server error"}',
           500,
         ));
       
       // ตรวจสอบว่าเกิด exception
       expect(
         () => apiService.fetchUsers(),
         throwsException,
       );
     });
   }
   ```

   2. Integration Testing กับ mock server:
   - ใช้ package เช่น mock_web_server
   - จำลอง API server ในขณะทดสอบ
   - สามารถกำหนด responses ต่างๆ ได้

   3. การทดสอบ Widget ที่ใช้ API:
   ```dart
   testWidgets('UserListScreen shows users when loaded', (tester) async {
     // Mock API service
     final mockApiService = MockApiService();
     when(mockApiService.fetchUsers())
       .thenAnswer((_) async => [User(id: 1, name: 'John')]);
     
     // Build widget
     await tester.pumpWidget(
       MaterialApp(
         home: Provider.value(
           value: mockApiService,
           child: UserListScreen(),
         ),
       ),
     );
     
     // ตรวจสอบว่าแสดง loading indicator
     expect(find.byType(CircularProgressIndicator), findsOneWidget);
     
     // รอให้ API ทำงานเสร็จ
     await tester.pumpAndSettle();
     
     // ตรวจสอบว่าแสดงรายชื่อผู้ใช้
     expect(find.text('John'), findsOneWidget);
   });
   